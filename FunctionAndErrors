// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MangsatGasoline {

    struct Pump {
        uint256 pumpId;
        uint256 pricePerLiter;
        uint256 availableLiters;
    }

    mapping(uint256 => Pump) public pumps;
    mapping(address => uint256) public excessFunds;
    
    event FuelPurchased(address indexed buyer, uint256 pumpId, uint256 liters, uint256 totalCost);
    event ExcessFundsWithdrawn(address indexed user, uint256 amount);
    
    address public owner;
    
    constructor() {
        owner = msg.sender;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can perform this action");
        _;
    }
    
    function addPump(uint256 _pumpId, uint256 _pricePerLiter, uint256 _initialLiters) external onlyOwner {
        if (pumps[_pumpId].pumpId != 0) {
            revert("Pump already exists"); // Check if pump already exists
        }
        pumps[_pumpId] = Pump(_pumpId, _pricePerLiter, _initialLiters);
    }
    
    function purchaseFuel(uint256 _pumpId, uint256 _liters) external payable {
        if (pumps[_pumpId].pumpId == 0) {
            revert("Pump does not exist"); // Check if pump exists
        }
        if (pumps[_pumpId].availableLiters < _liters) {
            revert("Not enough fuel available");
        }
        
        uint256 totalCost = _liters * pumps[_pumpId].pricePerLiter;
        if (msg.value < totalCost) {
            revert("Insufficient funds sent");
        }
        
        if (msg.value > totalCost) {
            excessFunds[msg.sender] += (msg.value - totalCost); // Add excess funds to the user's account
        }
        
        payable(owner).transfer(totalCost);
        
        pumps[_pumpId].availableLiters -= _liters;
        
        emit FuelPurchased(msg.sender, _pumpId, _liters, totalCost);
        
        // Assert to ensure the pump's availableLiters is non-negative
        assert(pumps[_pumpId].availableLiters >= 0);
    }
    
    function withdrawExcessFunds() external {
        uint256 amount = excessFunds[msg.sender];
        if (amount == 0) {
            revert("No excess funds available");
        }
        
        excessFunds[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        
        emit ExcessFundsWithdrawn(msg.sender, amount);
    }
}
